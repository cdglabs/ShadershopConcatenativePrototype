// Generated by CoffeeScript 1.6.3
(function() {
  var Fn, FnAbs, FnLinearMap, FnSin, FnX, Graph, capturePointer, compose, config, drawLine, drawManager, graph, lerp, pointerdown, refresh, resize, state, ticks, _base, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Fn = (function() {
    function Fn() {
      this.visible = true;
    }

    return Fn;

  })();

  FnX = (function(_super) {
    __extends(FnX, _super);

    function FnX() {
      this.fn = __bind(this.fn, this);
      FnX.__super__.constructor.call(this);
    }

    FnX.prototype.title = "x";

    FnX.prototype.fn = function(x) {
      return x;
    };

    return FnX;

  })(Fn);

  FnLinearMap = (function(_super) {
    __extends(FnLinearMap, _super);

    function FnLinearMap() {
      this.fn = __bind(this.fn, this);
      this.offset = 0;
      this.multiplier = 1;
      FnLinearMap.__super__.constructor.call(this);
    }

    FnLinearMap.prototype.title = "lerp(…)";

    FnLinearMap.prototype.fn = function(x) {
      return (x * this.multiplier) + this.offset;
    };

    FnLinearMap.prototype.draw = function(graph) {
      var _this = this;
      graph.drawGraph((function(x) {
        return _this.offset;
      }), "rgba(0, 127, 0, 1.0)");
      return graph.drawGraph((function(x) {
        return _this.offset + _this.multiplier;
      }), "rgba(0, 127, 0, 0.6)");
    };

    FnLinearMap.prototype.pointerdown = function(e, graph) {
      var hit, originalMultiplier, originalOffset, originalY, x, y, _ref, _ref1,
        _this = this;
      hit = graph.hitDetect(e.clientY, [this.offset, this.offset + this.multiplier]);
      if (hit === 0) {
        _ref = graph.getCoords([e.clientX, e.clientY]), x = _ref[0], y = _ref[1];
        originalY = y;
        originalOffset = this.offset;
        return capturePointer(e, function(e) {
          var dy, _ref1;
          _ref1 = graph.getCoords([e.clientX, e.clientY]), x = _ref1[0], y = _ref1[1];
          dy = y - originalY;
          _this.offset = originalOffset + dy;
          return refresh();
        });
      } else if (hit === 1) {
        _ref1 = graph.getCoords([e.clientX, e.clientY]), x = _ref1[0], y = _ref1[1];
        originalY = y;
        originalMultiplier = this.offset + this.multiplier;
        return capturePointer(e, function(e) {
          var dy, _ref2;
          _ref2 = graph.getCoords([e.clientX, e.clientY]), x = _ref2[0], y = _ref2[1];
          dy = y - originalY;
          _this.multiplier = originalMultiplier + dy - _this.offset;
          return refresh();
        });
      }
    };

    return FnLinearMap;

  })(Fn);

  FnAbs = (function(_super) {
    __extends(FnAbs, _super);

    function FnAbs() {
      this.fn = __bind(this.fn, this);
      this.offset = 0;
      FnAbs.__super__.constructor.call(this);
    }

    FnAbs.prototype.title = "abs(…)";

    FnAbs.prototype.fn = function(x) {
      return Math.abs(x - this.offset) + this.offset;
    };

    FnAbs.prototype.draw = function(graph) {
      var _this = this;
      return graph.drawGraph((function(x) {
        return _this.offset;
      }), "rgba(0, 127, 0, 1.0)");
    };

    FnAbs.prototype.pointerdown = function(e, graph) {
      var move,
        _this = this;
      move = function(e) {
        var x, y, _ref;
        _ref = graph.getCoords([e.clientX, e.clientY]), x = _ref[0], y = _ref[1];
        _this.offset = y;
        return refresh();
      };
      capturePointer(e, move);
      return move(e);
    };

    return FnAbs;

  })(Fn);

  FnSin = (function(_super) {
    __extends(FnSin, _super);

    function FnSin() {
      this.fn = __bind(this.fn, this);
      FnSin.__super__.constructor.call(this);
    }

    FnSin.prototype.title = "sin(…)";

    FnSin.prototype.fn = function(x) {
      return Math.sin(x);
    };

    return FnSin;

  })(Fn);

  /*
  
  Need to snap to grid lines
    given a y value and a tolerance (pixels), find closest grid line (i.e. return a y value, either the same or snapped)
  
  Need to see how close a point is to an object, for hit detection
  */


  config = {
    minGridSpacing: 70,
    hitTolerance: 15,
    snapTolerance: 5
  };

  ticks = function(spacing, min, max) {
    var first, last, x, _i, _results;
    first = Math.ceil(min / spacing);
    last = Math.floor(max / spacing);
    _results = [];
    for (x = _i = first; first <= last ? _i <= last : _i >= last; x = first <= last ? ++_i : --_i) {
      _results.push(x * spacing);
    }
    return _results;
  };

  drawLine = function(ctx, _arg, _arg1) {
    var x1, x2, y1, y2;
    x1 = _arg[0], y1 = _arg[1];
    x2 = _arg1[0], y2 = _arg1[1];
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    return ctx.stroke();
  };

  Graph = (function() {
    function Graph(canvas, xMin, xMax, yMin, yMax) {
      this.canvas = canvas;
      this.xMin = xMin;
      this.xMax = xMax;
      this.yMin = yMin;
      this.yMax = yMax;
      this.ctx = this.canvas.getContext("2d");
    }

    Graph.prototype.width = function() {
      return this.canvas.width;
    };

    Graph.prototype.height = function() {
      return this.canvas.height;
    };

    Graph.prototype.hitDetect = function(targetBrowserY, yValues) {
      var browserY, distance, found, i, minDistance, y, _i, _len;
      minDistance = config.hitTolerance;
      found = false;
      for (i = _i = 0, _len = yValues.length; _i < _len; i = ++_i) {
        y = yValues[i];
        browserY = this.fromLocal([0, y])[1];
        distance = Math.abs(browserY - targetBrowserY);
        if (distance < minDistance) {
          found = i;
          minDistance = distance;
        }
      }
      return found;
    };

    Graph.prototype.findSpacing = function() {
      var div, largeSpacing, minSpacing, sizeX, sizeY, smallSpacing, xMinSpacing, yMinSpacing, z;
      sizeX = this.xMax - this.xMin;
      sizeY = this.yMax - this.yMin;
      xMinSpacing = (sizeX / this.width()) * config.minGridSpacing;
      yMinSpacing = (sizeY / this.height()) * config.minGridSpacing;
      minSpacing = Math.max(xMinSpacing, yMinSpacing);
      /*
      need to determine:
        largeSpacing = {1, 2, or 5} * 10^n
        smallSpacing = divide largeSpacing by 4 (if 1 or 2) or 5 (if 5)
      largeSpacing must be greater than minSpacing
      */

      div = 4;
      largeSpacing = z = Math.pow(10, Math.ceil(Math.log(minSpacing) / Math.log(10)));
      if (z / 5 > minSpacing) {
        largeSpacing = z / 5;
      } else if (z / 2 > minSpacing) {
        largeSpacing = z / 2;
        div = 5;
      }
      smallSpacing = largeSpacing / div;
      return [largeSpacing, smallSpacing];
    };

    Graph.prototype.getCoords = function(_arg) {
      var browserX, browserY, rect, x, y;
      browserX = _arg[0], browserY = _arg[1];
      rect = this.canvas.getBoundingClientRect();
      x = lerp(browserX, rect.left, rect.right, this.xMin, this.xMax);
      y = lerp(browserY, rect.top, rect.bottom, this.yMax, this.yMin);
      return [x, y];
    };

    Graph.prototype.fromLocal = function(_arg) {
      var browserX, browserY, rect, x, y;
      x = _arg[0], y = _arg[1];
      rect = this.canvas.getBoundingClientRect();
      browserX = lerp(x, this.xMin, this.xMax, rect.left, rect.right);
      browserY = lerp(y, this.yMin, this.yMax, rect.bottom, rect.top);
      return [browserX, browserY];
    };

    Graph.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, this.width(), this.height());
    };

    Graph.prototype.drawGrid = function() {
      var axesColor, axesOpacity, color, cx, cxMax, cxMin, cy, cyMax, cyMin, fromLocal, labelColor, labelDistance, labelOpacity, largeSpacing, majorColor, majorOpacity, minorColor, minorOpacity, sizeX, sizeY, smallSpacing, text, textHeight, toLocal, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
        _this = this;
      this.ctx.save();
      sizeX = this.xMax - this.xMin;
      sizeY = this.yMax - this.yMin;
      cxMin = 0;
      cxMax = this.width();
      cyMin = this.height();
      cyMax = 0;
      toLocal = function(_arg) {
        var cx, cy;
        cx = _arg[0], cy = _arg[1];
        return [lerp(cx, cxMin, cxMax, _this.xMin, _this.xMax), lerp(cy, cyMin, cyMax, _this.yMin, _this.yMax)];
      };
      fromLocal = function(_arg) {
        var x, y;
        x = _arg[0], y = _arg[1];
        return [lerp(x, _this.xMin, _this.xMax, cxMin, cxMax), lerp(y, _this.yMin, _this.yMax, cyMin, cyMax)];
      };
      labelDistance = 5;
      color = "0,0,0";
      minorOpacity = 0.1;
      majorOpacity = 0.2;
      axesOpacity = 0.5;
      labelOpacity = 1.0;
      textHeight = 12;
      minorColor = "rgba(" + color + ", " + minorOpacity + ")";
      majorColor = "rgba(" + color + ", " + majorOpacity + ")";
      axesColor = "rgba(" + color + ", " + axesOpacity + ")";
      labelColor = "rgba(" + color + ", " + labelOpacity + ")";
      _ref = this.findSpacing(), largeSpacing = _ref[0], smallSpacing = _ref[1];
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = minorColor;
      _ref1 = ticks(smallSpacing, this.xMin, this.xMax);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        drawLine(this.ctx, fromLocal([x, this.yMin]), fromLocal([x, this.yMax]));
      }
      _ref2 = ticks(smallSpacing, this.yMin, this.yMax);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        y = _ref2[_j];
        drawLine(this.ctx, fromLocal([this.xMin, y]), fromLocal([this.xMax, y]));
      }
      this.ctx.strokeStyle = majorColor;
      _ref3 = ticks(largeSpacing, this.xMin, this.xMax);
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        x = _ref3[_k];
        drawLine(this.ctx, fromLocal([x, this.yMin]), fromLocal([x, this.yMax]));
      }
      _ref4 = ticks(largeSpacing, this.yMin, this.yMax);
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        y = _ref4[_l];
        drawLine(this.ctx, fromLocal([this.xMin, y]), fromLocal([this.xMax, y]));
      }
      this.ctx.strokeStyle = axesColor;
      drawLine(this.ctx, fromLocal([0, this.yMin]), fromLocal([0, this.yMax]));
      drawLine(this.ctx, fromLocal([this.xMin, 0]), fromLocal([this.xMax, 0]));
      this.ctx.font = "" + textHeight + "px verdana";
      this.ctx.fillStyle = labelColor;
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "top";
      _ref5 = ticks(largeSpacing, this.xMin, this.xMax);
      for (_m = 0, _len4 = _ref5.length; _m < _len4; _m++) {
        x = _ref5[_m];
        if (x !== 0) {
          text = parseFloat(x.toPrecision(12)).toString();
          _ref6 = fromLocal([x, 0]), cx = _ref6[0], cy = _ref6[1];
          cy += labelDistance;
          if (cy < labelDistance) {
            cy = labelDistance;
          }
          if (cy + textHeight + labelDistance > this.height()) {
            cy = this.height() - labelDistance - textHeight;
          }
          this.ctx.fillText(text, cx, cy);
        }
      }
      this.ctx.textAlign = "left";
      this.ctx.textBaseline = "middle";
      _ref7 = ticks(largeSpacing, this.yMin, this.yMax);
      for (_n = 0, _len5 = _ref7.length; _n < _len5; _n++) {
        y = _ref7[_n];
        if (y !== 0) {
          text = parseFloat(y.toPrecision(12)).toString();
          _ref8 = fromLocal([0, y]), cx = _ref8[0], cy = _ref8[1];
          cx += labelDistance;
          if (cx < labelDistance) {
            cx = labelDistance;
          }
          if (cx + this.ctx.measureText(text).width + labelDistance > this.width()) {
            cx = this.width() - labelDistance - this.ctx.measureText(text).width;
          }
          this.ctx.fillText(text, cx, cy);
        }
      }
      return this.ctx.restore();
    };

    Graph.prototype.drawGraph = function(fn, color, lineWidth) {
      var cx, cxMax, cxMin, cy, cyMax, cyMin, i, resolution, sizeX, sizeY, x, y, _i, _ref;
      if (color == null) {
        color = "#006";
      }
      if (lineWidth == null) {
        lineWidth = 2;
      }
      this.ctx.save();
      sizeX = this.xMax - this.xMin;
      sizeY = this.yMax - this.yMin;
      cxMin = 0;
      cxMax = this.width();
      cyMin = this.height();
      cyMax = 0;
      this.ctx.lineWidth = lineWidth;
      this.ctx.strokeStyle = color;
      this.ctx.beginPath();
      resolution = 0.25;
      for (i = _i = 0, _ref = this.width() / resolution; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        cx = i * resolution;
        x = lerp(cx, cxMin, cxMax, this.xMin, this.xMax);
        y = fn(x);
        cy = lerp(y, this.yMin, this.yMax, cyMin, cyMax);
        this.ctx.lineTo(cx, cy);
      }
      this.ctx.stroke();
      return this.ctx.restore();
    };

    return Graph;

  })();

  graph = null;

  state = (function() {
    var startFn;
    startFn = new FnX();
    return {
      fns: [startFn],
      selected: startFn,
      fnsToAdd: [FnLinearMap, FnAbs, FnSin]
    };
  })();

  window.init = function() {
    var canvas;
    canvas = document.querySelector("#c");
    graph = new Graph(canvas, -10, 10, -10, 10);
    window.addEventListener("resize", resize);
    canvas.addEventListener("pointerdown", pointerdown);
    return resize();
  };

  resize = function() {
    var canvas, rect;
    canvas = document.querySelector("#c");
    rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    return refresh();
  };

  refresh = function() {
    var color, composedFn, fn, i, _i, _len, _ref, _ref1;
    drawManager();
    graph.clear();
    graph.drawGrid();
    composedFn = function(x) {
      return x;
    };
    _ref = state.fns;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      fn = _ref[i];
      composedFn = compose(fn.fn, composedFn);
      if (fn.visible) {
        if (fn === state.selected) {
          color = "#009";
        } else {
          color = "rgba(0,0,0,0.2)";
        }
        graph.drawGraph(composedFn, color);
      }
    }
    return (_ref1 = state.selected) != null ? typeof _ref1.draw === "function" ? _ref1.draw(graph) : void 0 : void 0;
  };

  pointerdown = function(e) {
    var _ref;
    e.preventDefault();
    return (_ref = state.selected) != null ? typeof _ref.pointerdown === "function" ? _ref.pointerdown(e, graph) : void 0 : void 0;
  };

  capturePointer = function(e, handleMove, handleUp) {
    var move, pointerId, up;
    pointerId = e.pointerId;
    move = function(e) {
      if (e.pointerId = pointerId) {
        return typeof handleMove === "function" ? handleMove(e) : void 0;
      }
    };
    up = function(e) {
      if (typeof handleUp === "function") {
        handleUp(e);
      }
      window.removeEventListener("pointermove", move);
      return window.removeEventListener("pointerup", up);
    };
    window.addEventListener("pointermove", move);
    return window.addEventListener("pointerup", up);
  };

  drawManager = (function() {
    var FnView, ManagerView, d, dif;
    d = React.DOM;
    dif = function(cond, fn) {
      if (cond) {
        return fn();
      } else {
        return null;
      }
    };
    FnView = React.createClass({
      select: function(e) {
        if (e.target.matches("input, button")) {
          return;
        }
        state.selected = this.props.fn;
        return refresh();
      },
      remove: function() {
        var fn, i, _ref;
        _ref = this.props, fn = _ref.fn, i = _ref.i;
        state.fns.splice(i, 1);
        if (state.selected = fn) {
          if (state.fns.length === i) {
            state.selected = state.fns[i - 1];
          } else {
            state.selected = state.fns[i];
          }
        }
        return refresh();
      },
      setVisibility: function(e) {
        var fn, i, _ref;
        _ref = this.props, fn = _ref.fn, i = _ref.i;
        fn.visible = e.target.checked;
        return refresh();
      },
      render: function() {
        var classNames, fn, i, _ref,
          _this = this;
        _ref = this.props, fn = _ref.fn, i = _ref.i;
        classNames = {
          fn: true,
          selected: fn === state.selected
        };
        return d.div({
          className: React.addons.classSet(classNames),
          onMouseDown: this.select
        }, dif(i > 0, function() {
          return d.button({
            onClick: _this.remove,
            style: {
              marginRight: 6
            }
          }, "X");
        }), d.input({
          type: "checkbox",
          onChange: this.setVisibility,
          checked: fn.visible,
          style: {
            marginRight: 6
          }
        }), d.span({}, fn.title));
      }
    });
    ManagerView = React.createClass({
      handleChange: function(e) {
        var fn, fnToAdd, i, placeToAdd;
        i = e.target.selectedIndex;
        e.target.selectedIndex = 0;
        if (i === 0) {
          return;
        }
        fnToAdd = state.fnsToAdd[i - 1];
        fn = new fnToAdd();
        placeToAdd = state.fns.indexOf(state.selected) + 1;
        state.fns.splice(placeToAdd, 0, fn);
        state.selected = fn;
        return refresh();
      },
      render: function() {
        var _this = this;
        return d.div({}, state.fns.map(function(fn, i) {
          return FnView({
            fn: fn,
            i: i
          });
        }), d.div({
          className: "fnsToAdd"
        }, d.select({
          onChange: this.handleChange
        }, d.option({
          value: "select"
        }, "Add..."), state.fnsToAdd.map(function(fnToAdd) {
          return d.option({}, fnToAdd.prototype.title);
        }))));
      }
    });
    return function() {
      var manager;
      manager = document.querySelector("#manager");
      return React.renderComponent(ManagerView(), manager);
    };
  })();

  lerp = function(x, dMin, dMax, rMin, rMax) {
    var ratio;
    ratio = (x - dMin) / (dMax - dMin);
    return ratio * (rMax - rMin) + rMin;
  };

  compose = function(f, g) {
    return function(x) {
      return f(g(x));
    };
  };

  if ((_base = Element.prototype).matches == null) {
    _base.matches = (_ref = (_ref1 = Element.prototype.webkitMatchesSelector) != null ? _ref1 : Element.prototype.mozMatchesSelector) != null ? _ref : Element.prototype.oMatchesSelector;
  }

  Element.prototype.closest = function(selector) {
    var fn, parent;
    if (_.isString(selector)) {
      fn = function(el) {
        return el.matches(selector);
      };
    } else {
      fn = selector;
    }
    if (fn(this)) {
      return this;
    } else {
      parent = this.parentNode;
      if ((parent != null) && parent.nodeType === Node.ELEMENT_NODE) {
        return parent.closest(fn);
      } else {
        return void 0;
      }
    }
  };

}).call(this);
