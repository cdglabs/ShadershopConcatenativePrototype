// Generated by CoffeeScript 1.6.3
/*

Need to snap to grid lines
  given a y value and a tolerance (pixels), find closest grid line (i.e. return a y value, either the same or snapped)

Need to see how close a point is to an object, for hit detection
*/


(function() {
  var Apply, Chain, Editor, Env, Fn, Graph, Link, Param, capturePointer, compose, config, drawLine, editor, fnsToAdd, lerp, mainGraph, pointerdown, refresh, refreshOnNextTick, refreshTinyGraphs, refreshView, resize, ticks, _base, _ref, _ref1;

  config = {
    minGridSpacing: 70,
    hitTolerance: 15,
    snapTolerance: 5
  };

  ticks = function(spacing, min, max) {
    var first, last, x, _i, _results;
    first = Math.ceil(min / spacing);
    last = Math.floor(max / spacing);
    _results = [];
    for (x = _i = first; first <= last ? _i <= last : _i >= last; x = first <= last ? ++_i : --_i) {
      _results.push(x * spacing);
    }
    return _results;
  };

  drawLine = function(ctx, _arg, _arg1) {
    var x1, x2, y1, y2;
    x1 = _arg[0], y1 = _arg[1];
    x2 = _arg1[0], y2 = _arg1[1];
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    return ctx.stroke();
  };

  Graph = (function() {
    function Graph(canvas, xMin, xMax, yMin, yMax) {
      this.canvas = canvas;
      this.xMin = xMin;
      this.xMax = xMax;
      this.yMin = yMin;
      this.yMax = yMax;
      this.ctx = this.canvas.getContext("2d");
    }

    Graph.prototype.width = function() {
      return this.canvas.width;
    };

    Graph.prototype.height = function() {
      return this.canvas.height;
    };

    Graph.prototype.hitDetect = function(targetBrowserY, yValues) {
      var browserY, distance, found, i, minDistance, y, _i, _len;
      minDistance = config.hitTolerance;
      found = false;
      for (i = _i = 0, _len = yValues.length; _i < _len; i = ++_i) {
        y = yValues[i];
        browserY = this.fromLocal([0, y])[1];
        distance = Math.abs(browserY - targetBrowserY);
        if (distance < minDistance) {
          found = i;
          minDistance = distance;
        }
      }
      return found;
    };

    Graph.prototype.findSpacing = function() {
      var div, largeSpacing, minSpacing, sizeX, sizeY, smallSpacing, xMinSpacing, yMinSpacing, z;
      sizeX = this.xMax - this.xMin;
      sizeY = this.yMax - this.yMin;
      xMinSpacing = (sizeX / this.width()) * config.minGridSpacing;
      yMinSpacing = (sizeY / this.height()) * config.minGridSpacing;
      minSpacing = Math.max(xMinSpacing, yMinSpacing);
      /*
      need to determine:
        largeSpacing = {1, 2, or 5} * 10^n
        smallSpacing = divide largeSpacing by 4 (if 1 or 2) or 5 (if 5)
      largeSpacing must be greater than minSpacing
      */

      div = 4;
      largeSpacing = z = Math.pow(10, Math.ceil(Math.log(minSpacing) / Math.log(10)));
      if (z / 5 > minSpacing) {
        largeSpacing = z / 5;
      } else if (z / 2 > minSpacing) {
        largeSpacing = z / 2;
        div = 5;
      }
      smallSpacing = largeSpacing / div;
      return [largeSpacing, smallSpacing];
    };

    Graph.prototype.getCoords = function(_arg) {
      var browserX, browserY, rect, x, y;
      browserX = _arg[0], browserY = _arg[1];
      rect = this.canvas.getBoundingClientRect();
      x = lerp(browserX, rect.left, rect.right, this.xMin, this.xMax);
      y = lerp(browserY, rect.top, rect.bottom, this.yMax, this.yMin);
      return [x, y];
    };

    Graph.prototype.fromLocal = function(_arg) {
      var browserX, browserY, rect, x, y;
      x = _arg[0], y = _arg[1];
      rect = this.canvas.getBoundingClientRect();
      browserX = lerp(x, this.xMin, this.xMax, rect.left, rect.right);
      browserY = lerp(y, this.yMin, this.yMax, rect.bottom, rect.top);
      return [browserX, browserY];
    };

    Graph.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, this.width(), this.height());
    };

    Graph.prototype.drawGrid = function() {
      var axesColor, axesOpacity, color, cx, cxMax, cxMin, cy, cyMax, cyMin, fromLocal, labelColor, labelDistance, labelOpacity, largeSpacing, majorColor, majorOpacity, minorColor, minorOpacity, sizeX, sizeY, smallSpacing, text, textHeight, toLocal, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
        _this = this;
      this.ctx.save();
      sizeX = this.xMax - this.xMin;
      sizeY = this.yMax - this.yMin;
      cxMin = 0;
      cxMax = this.width();
      cyMin = this.height();
      cyMax = 0;
      toLocal = function(_arg) {
        var cx, cy;
        cx = _arg[0], cy = _arg[1];
        return [lerp(cx, cxMin, cxMax, _this.xMin, _this.xMax), lerp(cy, cyMin, cyMax, _this.yMin, _this.yMax)];
      };
      fromLocal = function(_arg) {
        var x, y;
        x = _arg[0], y = _arg[1];
        return [lerp(x, _this.xMin, _this.xMax, cxMin, cxMax), lerp(y, _this.yMin, _this.yMax, cyMin, cyMax)];
      };
      labelDistance = 5;
      color = "0,0,0";
      minorOpacity = 0.1;
      majorOpacity = 0.2;
      axesOpacity = 0.5;
      labelOpacity = 1.0;
      textHeight = 12;
      minorColor = "rgba(" + color + ", " + minorOpacity + ")";
      majorColor = "rgba(" + color + ", " + majorOpacity + ")";
      axesColor = "rgba(" + color + ", " + axesOpacity + ")";
      labelColor = "rgba(" + color + ", " + labelOpacity + ")";
      _ref = this.findSpacing(), largeSpacing = _ref[0], smallSpacing = _ref[1];
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = minorColor;
      _ref1 = ticks(smallSpacing, this.xMin, this.xMax);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        drawLine(this.ctx, fromLocal([x, this.yMin]), fromLocal([x, this.yMax]));
      }
      _ref2 = ticks(smallSpacing, this.yMin, this.yMax);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        y = _ref2[_j];
        drawLine(this.ctx, fromLocal([this.xMin, y]), fromLocal([this.xMax, y]));
      }
      this.ctx.strokeStyle = majorColor;
      _ref3 = ticks(largeSpacing, this.xMin, this.xMax);
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        x = _ref3[_k];
        drawLine(this.ctx, fromLocal([x, this.yMin]), fromLocal([x, this.yMax]));
      }
      _ref4 = ticks(largeSpacing, this.yMin, this.yMax);
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        y = _ref4[_l];
        drawLine(this.ctx, fromLocal([this.xMin, y]), fromLocal([this.xMax, y]));
      }
      this.ctx.strokeStyle = axesColor;
      drawLine(this.ctx, fromLocal([0, this.yMin]), fromLocal([0, this.yMax]));
      drawLine(this.ctx, fromLocal([this.xMin, 0]), fromLocal([this.xMax, 0]));
      this.ctx.font = "" + textHeight + "px verdana";
      this.ctx.fillStyle = labelColor;
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "top";
      _ref5 = ticks(largeSpacing, this.xMin, this.xMax);
      for (_m = 0, _len4 = _ref5.length; _m < _len4; _m++) {
        x = _ref5[_m];
        if (x !== 0) {
          text = parseFloat(x.toPrecision(12)).toString();
          _ref6 = fromLocal([x, 0]), cx = _ref6[0], cy = _ref6[1];
          cy += labelDistance;
          if (cy < labelDistance) {
            cy = labelDistance;
          }
          if (cy + textHeight + labelDistance > this.height()) {
            cy = this.height() - labelDistance - textHeight;
          }
          this.ctx.fillText(text, cx, cy);
        }
      }
      this.ctx.textAlign = "left";
      this.ctx.textBaseline = "middle";
      _ref7 = ticks(largeSpacing, this.yMin, this.yMax);
      for (_n = 0, _len5 = _ref7.length; _n < _len5; _n++) {
        y = _ref7[_n];
        if (y !== 0) {
          text = parseFloat(y.toPrecision(12)).toString();
          _ref8 = fromLocal([0, y]), cx = _ref8[0], cy = _ref8[1];
          cx += labelDistance;
          if (cx < labelDistance) {
            cx = labelDistance;
          }
          if (cx + this.ctx.measureText(text).width + labelDistance > this.width()) {
            cx = this.width() - labelDistance - this.ctx.measureText(text).width;
          }
          this.ctx.fillText(text, cx, cy);
        }
      }
      return this.ctx.restore();
    };

    Graph.prototype.drawGraph = function(fn, styleOpts) {
      var cx, cxMax, cxMin, cy, cyMax, cyMin, i, resolution, sizeX, sizeY, x, y, _i, _ref, _ref1, _ref2, _ref3;
      this.ctx.save();
      sizeX = this.xMax - this.xMin;
      sizeY = this.yMax - this.yMin;
      cxMin = 0;
      cxMax = this.width();
      cyMin = this.height();
      cyMax = 0;
      this.ctx.lineWidth = (_ref = styleOpts.lineWidth) != null ? _ref : 2;
      this.ctx.strokeStyle = (_ref1 = styleOpts.color) != null ? _ref1 : "#006";
      this.ctx.globalAlpha = (_ref2 = styleOpts.opacity) != null ? _ref2 : 1;
      this.ctx.beginPath();
      resolution = 1;
      for (i = _i = 0, _ref3 = this.width() / resolution; 0 <= _ref3 ? _i <= _ref3 : _i >= _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
        cx = i * resolution;
        x = lerp(cx, cxMin, cxMax, this.xMin, this.xMax);
        y = fn(x);
        cy = lerp(y, this.yMin, this.yMax, cyMin, cyMax);
        this.ctx.lineTo(cx, cy);
      }
      this.ctx.stroke();
      return this.ctx.restore();
    };

    return Graph;

  })();

  mainGraph = null;

  window.init = function() {
    var canvas;
    canvas = document.querySelector("#c");
    mainGraph = new Graph(canvas, -10, 10, -10, 10);
    window.addEventListener("resize", resize);
    canvas.addEventListener("pointerdown", pointerdown);
    return resize();
  };

  resize = function() {
    var canvas, rect;
    canvas = document.querySelector("#c");
    rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    return refresh();
  };

  refresh = function() {
    refreshView();
    refreshTinyGraphs();
    mainGraph.clear();
    mainGraph.drawGrid();
    return editor.draw(mainGraph);
  };

  refreshTinyGraphs = function() {
    var canvas, drawData, graph, rect, _i, _len, _ref, _results;
    _ref = document.querySelectorAll("canvas");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      canvas = _ref[_i];
      if (!(drawData = canvas.drawData)) {
        continue;
      }
      rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      graph = canvas.graph != null ? canvas.graph : canvas.graph = new Graph(canvas, -10, 10, -10, 10);
      graph.clear();
      if ((drawData.chain != null) && (drawData.link != null)) {
        _results.push(editor.drawChainLink(graph, drawData.chain, drawData.link));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  refreshOnNextTick = (function() {
    var willRefreshOnNextTick;
    willRefreshOnNextTick = false;
    return function() {
      if (willRefreshOnNextTick) {
        return;
      }
      willRefreshOnNextTick;
      return setTimeout(function() {
        willRefreshOnNextTick = false;
        return refresh();
      }, 1);
    };
  })();

  pointerdown = function(e) {
    e.preventDefault();
    document.activeElement.blur();
    return editor.pointerdown(e, mainGraph);
  };

  Param = (function() {
    function Param(value) {
      this.value = value != null ? value : 0;
      this.id = _.uniqueId("p");
      this.title = "";
    }

    Param.prototype.evaluate = function(env) {
      var _ref;
      return (_ref = env.lookup(this)) != null ? _ref : this.value;
    };

    return Param;

  })();

  Env = (function() {
    function Env() {
      this.paramValues = {};
    }

    Env.prototype.set = function(param, value) {
      return this.paramValues[param.id] = value;
    };

    Env.prototype.lookup = function(param) {
      return this.paramValues[param.id];
    };

    return Env;

  })();

  Fn = (function() {
    function Fn(title, numParams, compute) {
      this.title = title;
      this.numParams = numParams;
      this.compute = compute;
    }

    return Fn;

  })();

  fnsToAdd = [
    new Fn("+", 2, function(a, b) {
      return a + b;
    }), new Fn("-", 2, function(a, b) {
      return a - b;
    }), new Fn("*", 2, function(a, b) {
      return a * b;
    }), new Fn("/", 2, function(a, b) {
      return a / b;
    }), new Fn("abs", 1, function(a) {
      return Math.abs(a);
    }), new Fn("sin", 1, function(a) {
      return Math.sin(a);
    }), new Fn("cos", 1, function(a) {
      return Math.cos(a);
    })
  ];

  Apply = (function() {
    function Apply(fn, params) {
      this.fn = fn;
      this.params = params;
    }

    Apply.prototype.evaluate = function(env) {
      var paramValues, _ref;
      paramValues = this.params.map(function(param) {
        return param.evaluate(env);
      });
      return (_ref = this.fn).compute.apply(_ref, paramValues);
    };

    return Apply;

  })();

  Chain = (function() {
    function Chain(startParam) {
      this.startParam = startParam;
      this.links = [];
    }

    Chain.prototype.appendLink = function(fn) {
      var additionalParams, link, _i, _ref, _results;
      additionalParams = (function() {
        _results = [];
        for (var _i = 0, _ref = fn.numParams - 1; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function() {
        return new Param();
      });
      link = new Link(fn, additionalParams);
      this.links.push(link);
      return link;
    };

    return Chain;

  })();

  Link = (function() {
    function Link(fn, additionalParams) {
      this.fn = fn;
      this.additionalParams = additionalParams;
      this.visible = true;
      this.id = _.uniqueId("l");
    }

    return Link;

  })();

  Editor = (function() {
    function Editor() {
      this.params = [];
      this.chains = [];
      this.xParam = null;
      this.hoveredLink = null;
      this.selectedLink = null;
      this.hoveredParam = null;
    }

    Editor.prototype.addParam = function() {
      var param;
      param = new Param();
      this.params.push(param);
      return param;
    };

    Editor.prototype.addChain = function(startParam) {
      var chain;
      chain = new Chain(startParam);
      this.chains.push(chain);
      return chain;
    };

    Editor.prototype.makeEnv = function(xValue) {
      var env;
      env = new Env();
      if (this.xParam) {
        env.set(this.xParam, xValue);
      }
      return env;
    };

    Editor.prototype.draw = function(graph) {
      var chain, link, param, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = this.visibleParams();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        this.drawParam(graph, param);
      }
      _ref1 = this.chains;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        chain = _ref1[_j];
        _results.push((function() {
          var _k, _len2, _ref2, _results1;
          _ref2 = chain.links;
          _results1 = [];
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            link = _ref2[_k];
            _results1.push(this.drawChainLink(graph, chain, link));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Editor.prototype.drawParam = function(graph, param) {
      var graphFn,
        _this = this;
      graphFn = function(xValue) {
        var env;
        env = _this.makeEnv(xValue);
        return param.evaluate(env);
      };
      return graph.drawGraph(graphFn, {
        color: "green"
      });
    };

    Editor.prototype.drawChainLink = function(graph, chain, link) {
      var apply, graphFn, styleOpts,
        _this = this;
      apply = this.applyForChainLink(chain, link);
      if (link === this.selectedLink) {
        styleOpts = {
          color: "#009"
        };
      } else if (link === this.hoveredLink) {
        styleOpts = {
          color: "#bbf"
        };
      } else {
        styleOpts = {
          color: "#000",
          opacity: 0.2
        };
      }
      graphFn = function(xValue) {
        var env;
        env = _this.makeEnv(xValue);
        return apply.evaluate(env);
      };
      return graph.drawGraph(graphFn, styleOpts);
    };

    Editor.prototype.applyForChainLink = function(chain, link) {
      var apply, l, params, _i, _len, _ref;
      apply = chain.startParam;
      _ref = chain.links;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        params = [apply].concat(l.additionalParams);
        apply = new Apply(l.fn, params);
        if (l === link) {
          break;
        }
      }
      return apply;
    };

    Editor.prototype.visibleParams = function() {
      var result;
      result = this.params;
      if (this.selectedLink) {
        result = _.union(result, this.selectedLink.additionalParams);
      }
      if (this.hoveredParam) {
        result = _.union(result, this.hoveredParam);
      }
      return result;
    };

    Editor.prototype.manipulableParams = function() {
      var result,
        _this = this;
      result = this.visibleParams();
      result = _.reject(result, function(param) {
        return param === _this.xParam;
      });
      return result;
    };

    Editor.prototype.hitDetect = function(e, graph) {
      var foundIndex, paramValues, params;
      params = this.manipulableParams();
      paramValues = _.map(params, function(param) {
        return param.value;
      });
      foundIndex = graph.hitDetect(e.clientY, paramValues);
      if (foundIndex != null) {
        return params[foundIndex];
      } else {
        return null;
      }
    };

    Editor.prototype.pointerdown = function(e, graph) {
      var param, setParam;
      param = this.hitDetect(e, graph);
      if (!param) {
        return;
      }
      setParam = function(e) {
        var x, y, _ref;
        _ref = graph.getCoords([e.clientX, e.clientY]), x = _ref[0], y = _ref[1];
        param.value = y;
        return refresh();
      };
      setParam(e);
      return capturePointer(e, setParam);
    };

    return Editor;

  })();

  editor = new Editor();

  (function() {
    var a, chain;
    a = editor.addParam();
    editor.xParam = a;
    return chain = editor.addChain(a);
  })();

  lerp = function(x, dMin, dMax, rMin, rMax) {
    var ratio;
    ratio = (x - dMin) / (dMax - dMin);
    return ratio * (rMax - rMin) + rMin;
  };

  compose = function(f, g) {
    return function(x) {
      return f(g(x));
    };
  };

  if ((_base = Element.prototype).matches == null) {
    _base.matches = (_ref = (_ref1 = Element.prototype.webkitMatchesSelector) != null ? _ref1 : Element.prototype.mozMatchesSelector) != null ? _ref : Element.prototype.oMatchesSelector;
  }

  Element.prototype.closest = function(selector) {
    var fn, parent;
    if (_.isString(selector)) {
      fn = function(el) {
        return el.matches(selector);
      };
    } else {
      fn = selector;
    }
    if (fn(this)) {
      return this;
    } else {
      parent = this.parentNode;
      if ((parent != null) && parent.nodeType === Node.ELEMENT_NODE) {
        return parent.closest(fn);
      } else {
        return void 0;
      }
    }
  };

  capturePointer = function(e, handleMove, handleUp) {
    var move, pointerId, up;
    pointerId = e.pointerId;
    move = function(e) {
      if (e.pointerId = pointerId) {
        return typeof handleMove === "function" ? handleMove(e) : void 0;
      }
    };
    up = function(e) {
      if (typeof handleUp === "function") {
        handleUp(e);
      }
      window.removeEventListener("pointermove", move);
      return window.removeEventListener("pointerup", up);
    };
    window.addEventListener("pointermove", move);
    return window.addEventListener("pointerup", up);
  };

  refreshView = (function() {
    var ChainView, EditorView, LinkView, ParamTitleView, ParamValueView, ParamView, cx, d, truncate;
    d = React.DOM;
    cx = React.addons.classSet;
    truncate = function(value) {
      var decimalPlace, s;
      s = "" + value;
      decimalPlace = s.indexOf(".");
      if (decimalPlace) {
        return s.substr(0, decimalPlace + 4);
      }
    };
    ParamValueView = React.createClass({
      render: function() {
        var param,
          _this = this;
        param = this.props.param;
        return d.span({
          className: "paramValue"
        }, (function() {
          if (editor.xParam === param) {
            return d.i({}, "x");
          } else {
            return truncate(param.value);
          }
        })());
      }
    });
    ParamTitleView = React.createClass({
      handleInput: function() {
        var el, newTitle;
        el = this.refs.span.getDOMNode();
        newTitle = el.textContent;
        if (el.innerHTML !== newTitle) {
          el.innerHTML = newTitle;
        }
        this.props.param.title = newTitle;
        return refresh();
      },
      render: function() {
        var param;
        param = this.props.param;
        return d.span({
          className: "paramTitle",
          contentEditable: "true",
          onInput: this.handleInput,
          ref: "span"
        }, param.title);
      }
    });
    ParamView = React.createClass({
      handleMouseEnter: function() {
        editor.hoveredParam = this.props.param;
        return refresh();
      },
      handleMouseLeave: function() {
        editor.hoveredParam = null;
        return refresh();
      },
      render: function() {
        var classNames;
        classNames = cx({
          param: true,
          hovered: this.props.param === editor.hoveredParam
        });
        return d.div({
          className: classNames,
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave
        }, ParamTitleView({
          param: this.props.param
        }), ParamValueView({
          param: this.props.param
        }));
      }
    });
    ChainView = React.createClass({
      handleChange: function(e) {
        var fn, i;
        i = e.target.selectedIndex;
        e.target.selectedIndex = 0;
        if (i === 0) {
          return;
        }
        fn = fnsToAdd[i - 1];
        this.props.chain.appendLink(fn);
        return refresh();
      },
      render: function() {
        var chain,
          _this = this;
        chain = this.props.chain;
        return d.div({
          className: "chain"
        }, d.div({
          className: "startParam row"
        }, ParamView({
          param: chain.startParam
        })), d.div({
          className: "links"
        }, chain.links.map(function(link) {
          return LinkView({
            link: link,
            chain: chain,
            key: link.id
          });
        })), d.div({
          className: "addFns row"
        }, d.select({
          onChange: this.handleChange
        }, d.option({
          value: "select"
        }, "Add..."), fnsToAdd.map(function(fn) {
          return d.option({}, fn.title);
        }))));
      }
    });
    LinkView = React.createClass({
      handleMouseDown: function() {
        editor.selectedLink = this.props.link;
        return refresh();
      },
      handleMouseEnter: function() {
        editor.hoveredLink = this.props.link;
        return refresh();
      },
      handleMouseLeave: function() {
        editor.hoveredLink = null;
        return refresh();
      },
      componentDidMount: function() {
        var canvasEl, chain, link, _ref2;
        _ref2 = this.props, chain = _ref2.chain, link = _ref2.link;
        canvasEl = this.refs.canvas.getDOMNode();
        canvasEl.drawData = {
          chain: chain,
          link: link
        };
        return refreshTinyGraphs();
      },
      render: function() {
        var classNames, link;
        link = this.props.link;
        classNames = cx({
          "link": true,
          "row": true,
          "selectedLink": link === editor.selectedLink,
          "hoveredLink": link === editor.hoveredLink
        });
        return d.div({
          className: classNames,
          onMouseDown: this.handleMouseDown,
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave
        }, d.div({
          className: "additionalParams",
          style: {
            float: "right"
          }
        }, link.additionalParams.map(function(param, i) {
          return ParamView({
            param: param,
            key: i
          });
        })), d.div({
          className: "tinyGraph"
        }, d.canvas({
          ref: "canvas"
        })), d.span({
          className: "linkTitle"
        }, link.fn.title));
      }
    });
    EditorView = React.createClass({
      render: function() {
        return d.div({
          className: "editor"
        }, d.div({
          className: "heading row"
        }, "Parameters"), editor.params.map(function(param) {
          return d.div({
            className: "row",
            key: param.id
          }, ParamView({
            param: param
          }));
        }), d.div({
          className: "heading row"
        }, "Chain"), editor.chains.map(function(chain) {
          return ChainView({
            chain: chain
          });
        }));
      }
    });
    return function() {
      var manager;
      manager = document.querySelector("#manager");
      return React.renderComponent(EditorView(), manager);
    };
  })();

}).call(this);
