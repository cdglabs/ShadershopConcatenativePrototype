// Generated by CoffeeScript 1.6.3
(function() {
  var AnnotateMixin, Apply, ApplyInternalsView, ApplyRowView, ApplyThumbnailView, ApplyView, CanvasView, ContentEditableMixin, DataForMixin, DraggingView, Editor, Fn, Graph, GraphView, GridView, MainGraphView, ObjectManager, Param, ParamSlotView, ParamTitleView, ParamValueView, ParamView, PossibleApplyView, ProvisionalApply, ProvisionalApplyView, R, Shader, ShaderGraphView, closestDataFor, compose, config, cx, drawLine, editor, fnsToAdd, lerp, loadInitialEditor, loadState, objectManager, onceDragConsummated, pointermove, pointerup, refresh, refreshView, saveState, ticks, truncate, _base, _ref, _ref1,
    __hasProp = {}.hasOwnProperty;

  AnnotateMixin = {
    componentDidMount: function() {
      return this.updateAnnotations();
    },
    componentDidUpdate: function() {
      return this.updateAnnotations();
    },
    updateAnnotations: function() {
      var annotation, annotations, component, el, refName, _ref, _results;
      if (!this.annotate) {
        return;
      }
      annotations = this.annotate();
      if (!annotations) {
        return;
      }
      _results = [];
      for (refName in annotations) {
        if (!__hasProp.call(annotations, refName)) continue;
        annotation = annotations[refName];
        if (refName === "self") {
          component = this;
        } else {
          component = (_ref = this.refs) != null ? _ref[refName] : void 0;
        }
        el = component != null ? component.getDOMNode() : void 0;
        if (el) {
          _results.push(el.annotation = annotation);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  DataForMixin = {
    componentDidMount: function() {
      return this.updateDataForAnnotation();
    },
    componentDidUpdate: function() {
      return this.updateDataForAnnotation();
    },
    updateDataForAnnotation: function() {
      var el;
      el = this.getDOMNode();
      return el.dataFor = this;
    }
  };

  ApplyView = React.createClass({
    mixins: [DataForMixin],
    handleMouseDown: function(e) {
      var apply, el, offset, rect,
        _this = this;
      if (e.target.closest(".param") != null) {
        return;
      }
      if (e.target.closest(".applyThumbnail") != null) {
        return;
      }
      if (this.props.isProvisional) {
        return;
      }
      apply = this.props.apply;
      e.preventDefault();
      if (apply instanceof Param) {
        return;
      }
      el = this.getDOMNode();
      rect = el.getBoundingClientRect();
      offset = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
      editor.dragging = {
        cursor: "-webkit-grabbing"
      };
      return onceDragConsummated(e, function() {
        return editor.dragging = {
          cursor: "-webkit-grabbing",
          offset: offset,
          apply: apply,
          render: function() {
            return R.div({
              style: {
                width: rect.width,
                height: rect.height
              }
            }, ApplyView({
              apply: apply,
              isDraggingCopy: true
            }));
          },
          onMove: function(e) {
            var applyEl, applyEls, insertAfterEl, myHeight, refApply, _i, _len, _ref, _ref1;
            insertAfterEl = null;
            applyEls = document.querySelectorAll(".manager .apply");
            for (_i = 0, _len = applyEls.length; _i < _len; _i++) {
              applyEl = applyEls[_i];
              rect = applyEl.getBoundingClientRect();
              myHeight = 37;
              if ((rect.bottom + myHeight * 1.5 > (_ref = e.clientY) && _ref > rect.top + myHeight / 2) && (rect.left < (_ref1 = e.clientX) && _ref1 < rect.right)) {
                insertAfterEl = applyEl;
              }
            }
            editor.removeApply(apply);
            if (insertAfterEl) {
              refApply = insertAfterEl.dataFor.props.apply;
              return editor.insertApplyAfter(apply, refApply);
            }
          }
        };
      });
    },
    render: function() {
      var apply, classNames, isDraggingCopy, _ref, _ref1;
      _ref = this.props, apply = _ref.apply, isDraggingCopy = _ref.isDraggingCopy;
      if (!isDraggingCopy && apply === ((_ref1 = editor.dragging) != null ? _ref1.apply : void 0)) {
        return R.div({
          className: "applyPlaceholder"
        });
      }
      classNames = cx({
        apply: true,
        hovered: apply === editor.hoveredApply,
        isStart: typeof apply.isStart === "function" ? apply.isStart() : void 0
      });
      return R.div({
        className: classNames,
        style: {
          cursor: "-webkit-grab"
        },
        onMouseDown: this.handleMouseDown
      }, ApplyInternalsView({
        apply: apply
      }));
    }
  });

  ApplyInternalsView = React.createClass({
    render: function() {
      var apply;
      apply = this.props.apply;
      return R.div({
        className: "applyInternals"
      }, apply instanceof Param ? R.div({
        className: "paramSlot"
      }, ParamView({
        param: apply
      })) : [
        R.div({
          className: "fnTitle"
        }, apply.fn.title), apply.params.map(function(param, paramIndex) {
          if (paramIndex === 0) {
            return null;
          }
          return ParamSlotView({
            param: param,
            apply: apply,
            paramIndex: paramIndex
          });
        })
      ], ApplyThumbnailView({
        apply: apply
      }));
    }
  });

  ParamSlotView = React.createClass({
    mixins: [DataForMixin],
    handleTransclusionDrop: function(p) {
      var apply, param, paramIndex, _ref;
      _ref = this.props, param = _ref.param, apply = _ref.apply, paramIndex = _ref.paramIndex;
      return apply.setParam(paramIndex, p);
    },
    render: function() {
      var apply, param, paramIndex, _ref;
      _ref = this.props, param = _ref.param, apply = _ref.apply, paramIndex = _ref.paramIndex;
      return R.div({
        className: "paramSlot"
      }, param instanceof Param ? ParamView({
        param: param
      }) : ApplyThumbnailView({
        apply: param
      }));
    }
  });

  ApplyThumbnailView = React.createClass({
    handleMouseDown: function(e) {
      var apply, el, offset, rect,
        _this = this;
      e.preventDefault();
      apply = this.props.apply;
      el = this.getDOMNode();
      rect = el.getBoundingClientRect();
      offset = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
      editor.dragging = {
        cursor: "-webkit-grabbing"
      };
      return onceDragConsummated(e, function() {
        return editor.dragging = {
          cursor: "-webkit-grabbing",
          offset: offset,
          render: function() {
            return ApplyThumbnailView({
              apply: apply
            });
          },
          transclusion: apply
        };
      });
    },
    handleMouseEnter: function(e) {
      return editor.hoveredApply = this.props.apply;
    },
    handleMouseLeave: function(e) {
      return editor.hoveredApply = null;
    },
    render: function() {
      var apply, graphViews, i, param, styleOpts, _i, _len, _ref;
      apply = this.props.apply;
      graphViews = [];
      if (apply.params && !(typeof apply.isStart === "function" ? apply.isStart() : void 0)) {
        _ref = apply.params;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          param = _ref[i];
          if (param instanceof Param && param !== editor.xParam) {
            styleOpts = config.styles.param;
          } else {
            styleOpts = config.styles.apply;
          }
          graphViews.push(GraphView({
            apply: param,
            styleOpts: styleOpts,
            key: i
          }));
        }
      }
      if (apply === editor.hoveredApply) {
        styleOpts = config.styles.hoveredApply;
      } else {
        styleOpts = config.styles.selectedApply;
      }
      graphViews.push(GraphView({
        apply: apply,
        styleOpts: styleOpts,
        key: "result"
      }));
      return R.div({
        className: "applyThumbnail",
        style: {
          cursor: "-webkit-grab"
        },
        onMouseDown: this.handleMouseDown,
        onMouseEnter: this.handleMouseEnter,
        onMouseLeave: this.handleMouseLeave
      }, graphViews);
    }
  });

  PossibleApplyView = React.createClass({
    handleMouseEnter: function() {
      this.props.apply.selectedApply = this.props.possibleApply;
      return editor.hoveredParam = this.props.possibleApply.params[1];
    },
    handleMouseLeave: function() {
      this.props.apply.selectedApply = null;
      return editor.hoveredParam = null;
    },
    handleClick: function() {
      editor.replaceApply(this.props.possibleApply, this.props.apply);
      return editor.hoveredParam = null;
    },
    render: function() {
      var apply, classNames, possibleApply, _ref;
      _ref = this.props, apply = _ref.apply, possibleApply = _ref.possibleApply;
      classNames = cx({
        possibleApply: true,
        selectedPossibleApply: apply.selectedApply === possibleApply
      });
      return R.div({
        className: classNames,
        onClick: this.handleClick,
        onMouseEnter: this.handleMouseEnter,
        onMouseLeave: this.handleMouseLeave
      }, ApplyInternalsView({
        apply: possibleApply
      }));
    }
  });

  ProvisionalApplyView = React.createClass({
    render: function() {
      var apply;
      apply = this.props.apply;
      return R.div({
        className: "provisionalApply"
      }, apply.possibleApplies.map(function(possibleApply) {
        return PossibleApplyView({
          apply: apply,
          possibleApply: possibleApply
        });
      }));
    }
  });

  ApplyRowView = React.createClass({
    toggleProvisionalApply: function() {
      var apply, nextApply;
      apply = this.props.apply;
      nextApply = editor.nextApply(apply);
      if (nextApply instanceof ProvisionalApply) {
        return editor.removeApply(nextApply);
      } else {
        return editor.insertApplyAfter(new ProvisionalApply(), apply);
      }
    },
    render: function() {
      var apply;
      apply = this.props.apply;
      return R.div({
        className: "applyRow"
      }, apply instanceof ProvisionalApply ? ProvisionalApplyView({
        apply: apply
      }) : [
        ApplyView({
          apply: apply
        }), R.button({
          className: "addApplyButton",
          onClick: this.toggleProvisionalApply
        }, "+")
      ]);
    }
  });

  DraggingView = React.createClass({
    render: function() {
      var _ref;
      return R.div({}, ((_ref = editor.dragging) != null ? _ref.render : void 0) ? R.div({
        className: "draggingObject",
        style: {
          left: editor.mousePosition.x - editor.dragging.offset.x,
          top: editor.mousePosition.y - editor.dragging.offset.y
        }
      }, editor.dragging.render()) : void 0, editor.dragging ? R.div({
        className: "draggingOverlay"
      }) : void 0);
    }
  });

  /*
  
  Need to snap to grid lines
    given a y value and a tolerance (pixels), find closest grid line (i.e. return a y value, either the same or snapped)
  
  Need to see how close a point is to an object, for hit detection
  */


  ticks = function(spacing, min, max) {
    var first, last, x, _i, _results;
    first = Math.ceil(min / spacing);
    last = Math.floor(max / spacing);
    _results = [];
    for (x = _i = first; first <= last ? _i <= last : _i >= last; x = first <= last ? ++_i : --_i) {
      _results.push(x * spacing);
    }
    return _results;
  };

  drawLine = function(ctx, _arg, _arg1) {
    var x1, x2, y1, y2;
    x1 = _arg[0], y1 = _arg[1];
    x2 = _arg1[0], y2 = _arg1[1];
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    return ctx.stroke();
  };

  Graph = (function() {
    function Graph(canvas, xMin, xMax, yMin, yMax) {
      this.canvas = canvas;
      this.xMin = xMin;
      this.xMax = xMax;
      this.yMin = yMin;
      this.yMax = yMax;
      this.ctx = this.canvas.getContext("2d");
    }

    Graph.prototype.width = function() {
      return this.canvas.width;
    };

    Graph.prototype.height = function() {
      return this.canvas.height;
    };

    Graph.prototype.hitDetect = function(targetBrowserY, yValues) {
      var browserY, distance, found, i, minDistance, y, _i, _len;
      minDistance = config.hitTolerance;
      found = false;
      for (i = _i = 0, _len = yValues.length; _i < _len; i = ++_i) {
        y = yValues[i];
        browserY = this.fromLocal([0, y])[1];
        distance = Math.abs(browserY - targetBrowserY);
        if (distance < minDistance) {
          found = i;
          minDistance = distance;
        }
      }
      return found;
    };

    Graph.prototype.findSpacing = function() {
      var div, largeSpacing, minSpacing, sizeX, sizeY, smallSpacing, xMinSpacing, yMinSpacing, z;
      sizeX = this.xMax - this.xMin;
      sizeY = this.yMax - this.yMin;
      xMinSpacing = (sizeX / this.width()) * config.minGridSpacing;
      yMinSpacing = (sizeY / this.height()) * config.minGridSpacing;
      minSpacing = Math.max(xMinSpacing, yMinSpacing);
      /*
      need to determine:
        largeSpacing = {1, 2, or 5} * 10^n
        smallSpacing = divide largeSpacing by 4 (if 1 or 2) or 5 (if 5)
      largeSpacing must be greater than minSpacing
      */

      div = 4;
      largeSpacing = z = Math.pow(10, Math.ceil(Math.log(minSpacing) / Math.log(10)));
      if (z / 5 > minSpacing) {
        largeSpacing = z / 5;
      } else if (z / 2 > minSpacing) {
        largeSpacing = z / 2;
        div = 5;
      }
      smallSpacing = largeSpacing / div;
      return [largeSpacing, smallSpacing];
    };

    Graph.prototype.getCoords = function(_arg) {
      var browserX, browserY, rect, x, y;
      browserX = _arg[0], browserY = _arg[1];
      rect = this.canvas.getBoundingClientRect();
      x = lerp(browserX, rect.left, rect.right, this.xMin, this.xMax);
      y = lerp(browserY, rect.top, rect.bottom, this.yMax, this.yMin);
      return [x, y];
    };

    Graph.prototype.fromLocal = function(_arg) {
      var browserX, browserY, rect, x, y;
      x = _arg[0], y = _arg[1];
      rect = this.canvas.getBoundingClientRect();
      browserX = lerp(x, this.xMin, this.xMax, rect.left, rect.right);
      browserY = lerp(y, this.yMin, this.yMax, rect.bottom, rect.top);
      return [browserX, browserY];
    };

    Graph.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, this.width(), this.height());
    };

    Graph.prototype.drawGrid = function() {
      var axesColor, axesOpacity, color, cx, cxMax, cxMin, cy, cyMax, cyMin, fromLocal, labelColor, labelDistance, labelOpacity, largeSpacing, majorColor, majorOpacity, minorColor, minorOpacity, sizeX, sizeY, smallSpacing, text, textHeight, toLocal, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
        _this = this;
      this.ctx.save();
      sizeX = this.xMax - this.xMin;
      sizeY = this.yMax - this.yMin;
      cxMin = 0;
      cxMax = this.width();
      cyMin = this.height();
      cyMax = 0;
      toLocal = function(_arg) {
        var cx, cy;
        cx = _arg[0], cy = _arg[1];
        return [lerp(cx, cxMin, cxMax, _this.xMin, _this.xMax), lerp(cy, cyMin, cyMax, _this.yMin, _this.yMax)];
      };
      fromLocal = function(_arg) {
        var x, y;
        x = _arg[0], y = _arg[1];
        return [lerp(x, _this.xMin, _this.xMax, cxMin, cxMax), lerp(y, _this.yMin, _this.yMax, cyMin, cyMax)];
      };
      labelDistance = 5;
      color = "0,0,0";
      minorOpacity = 0.05;
      majorOpacity = 0.1;
      axesOpacity = 0.3;
      labelOpacity = 0.3;
      textHeight = 12;
      minorColor = "rgba(" + color + ", " + minorOpacity + ")";
      majorColor = "rgba(" + color + ", " + majorOpacity + ")";
      axesColor = "rgba(" + color + ", " + axesOpacity + ")";
      labelColor = "rgba(" + color + ", " + labelOpacity + ")";
      _ref = this.findSpacing(), largeSpacing = _ref[0], smallSpacing = _ref[1];
      this.ctx.lineWidth = 0.5;
      this.ctx.strokeStyle = minorColor;
      _ref1 = ticks(smallSpacing, this.xMin, this.xMax);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        drawLine(this.ctx, fromLocal([x, this.yMin]), fromLocal([x, this.yMax]));
      }
      _ref2 = ticks(smallSpacing, this.yMin, this.yMax);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        y = _ref2[_j];
        drawLine(this.ctx, fromLocal([this.xMin, y]), fromLocal([this.xMax, y]));
      }
      this.ctx.strokeStyle = majorColor;
      _ref3 = ticks(largeSpacing, this.xMin, this.xMax);
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        x = _ref3[_k];
        drawLine(this.ctx, fromLocal([x, this.yMin]), fromLocal([x, this.yMax]));
      }
      _ref4 = ticks(largeSpacing, this.yMin, this.yMax);
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        y = _ref4[_l];
        drawLine(this.ctx, fromLocal([this.xMin, y]), fromLocal([this.xMax, y]));
      }
      this.ctx.strokeStyle = axesColor;
      drawLine(this.ctx, fromLocal([0, this.yMin]), fromLocal([0, this.yMax]));
      drawLine(this.ctx, fromLocal([this.xMin, 0]), fromLocal([this.xMax, 0]));
      this.ctx.font = "" + textHeight + "px verdana";
      this.ctx.fillStyle = labelColor;
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "top";
      _ref5 = ticks(largeSpacing, this.xMin, this.xMax);
      for (_m = 0, _len4 = _ref5.length; _m < _len4; _m++) {
        x = _ref5[_m];
        if (x !== 0) {
          text = parseFloat(x.toPrecision(12)).toString();
          _ref6 = fromLocal([x, 0]), cx = _ref6[0], cy = _ref6[1];
          cy += labelDistance;
          if (cy < labelDistance) {
            cy = labelDistance;
          }
          if (cy + textHeight + labelDistance > this.height()) {
            cy = this.height() - labelDistance - textHeight;
          }
          this.ctx.fillText(text, cx, cy);
        }
      }
      this.ctx.textAlign = "left";
      this.ctx.textBaseline = "middle";
      _ref7 = ticks(largeSpacing, this.yMin, this.yMax);
      for (_n = 0, _len5 = _ref7.length; _n < _len5; _n++) {
        y = _ref7[_n];
        if (y !== 0) {
          text = parseFloat(y.toPrecision(12)).toString();
          _ref8 = fromLocal([0, y]), cx = _ref8[0], cy = _ref8[1];
          cx += labelDistance;
          if (cx < labelDistance) {
            cx = labelDistance;
          }
          if (cx + this.ctx.measureText(text).width + labelDistance > this.width()) {
            cx = this.width() - labelDistance - this.ctx.measureText(text).width;
          }
          this.ctx.fillText(text, cx, cy);
        }
      }
      return this.ctx.restore();
    };

    Graph.prototype.drawGraph = function(fn, styleOpts) {
      var cx, cxMax, cxMin, cy, cyMax, cyMin, dCy, i, lastCx, lastCy, lastSample, sizeX, sizeY, x, y, _i, _ref, _ref1, _ref2;
      this.ctx.save();
      sizeX = this.xMax - this.xMin;
      sizeY = this.yMax - this.yMin;
      cxMin = 0;
      cxMax = this.width();
      cyMin = this.height();
      cyMax = 0;
      this.ctx.lineWidth = (_ref = styleOpts.lineWidth) != null ? _ref : 2;
      this.ctx.strokeStyle = (_ref1 = styleOpts.color) != null ? _ref1 : "#006";
      this.ctx.globalAlpha = (_ref2 = styleOpts.opacity) != null ? _ref2 : 1;
      /*
      
      All this lastCy, etc. crap is to optimize having fewer lineTo calls. It
      fixes weird artifacting with straight lines in Chrome.
      */

      this.ctx.beginPath();
      lastSample = this.width() / config.resolution;
      lastCx = null;
      lastCy = null;
      dCy = null;
      for (i = _i = 0; 0 <= lastSample ? _i <= lastSample : _i >= lastSample; i = 0 <= lastSample ? ++_i : --_i) {
        cx = i * config.resolution;
        x = lerp(cx, cxMin, cxMax, this.xMin, this.xMax);
        y = fn(x);
        cy = lerp(y, this.yMin, this.yMax, cyMin, cyMax);
        if (lastCy == null) {
          this.ctx.moveTo(cx, cy);
        }
        if (dCy != null) {
          if (Math.abs((cy - lastCy) - dCy) > .000001) {
            this.ctx.lineTo(lastCx, lastCy);
          }
        }
        if (lastCy != null) {
          dCy = cy - lastCy;
        }
        lastCx = cx;
        lastCy = cy;
      }
      this.ctx.lineTo(cx, cy);
      this.ctx.stroke();
      return this.ctx.restore();
    };

    Graph.prototype.drawHorizontalLine = function(y, styleOpts) {
      var cxMax, cxMin, cy, cyMax, cyMin, _ref, _ref1, _ref2;
      this.ctx.save();
      cxMin = 0;
      cxMax = this.width();
      cyMin = this.height();
      cyMax = 0;
      cy = lerp(y, this.yMin, this.yMax, cyMin, cyMax);
      this.ctx.lineWidth = (_ref = styleOpts.lineWidth) != null ? _ref : 2;
      this.ctx.strokeStyle = (_ref1 = styleOpts.color) != null ? _ref1 : "#006";
      this.ctx.globalAlpha = (_ref2 = styleOpts.opacity) != null ? _ref2 : 1;
      this.ctx.beginPath();
      this.ctx.moveTo(cxMin, cy);
      this.ctx.lineTo(cxMax, cy);
      this.ctx.stroke();
      return this.ctx.restore();
    };

    Graph.prototype.drawVerticalLine = function(x, styleOpts) {
      var cx, cxMax, cxMin, cyMax, cyMin, _ref, _ref1, _ref2;
      this.ctx.save();
      cxMin = 0;
      cxMax = this.width();
      cyMin = this.height();
      cyMax = 0;
      cx = lerp(x, this.xMin, this.xMax, cxMin, cxMax);
      this.ctx.lineWidth = (_ref = styleOpts.lineWidth) != null ? _ref : 2;
      this.ctx.strokeStyle = (_ref1 = styleOpts.color) != null ? _ref1 : "#006";
      this.ctx.globalAlpha = (_ref2 = styleOpts.opacity) != null ? _ref2 : 1;
      this.ctx.beginPath();
      this.ctx.moveTo(cx, cyMin);
      this.ctx.lineTo(cx, cyMax);
      this.ctx.stroke();
      return this.ctx.restore();
    };

    return Graph;

  })();

  CanvasView = React.createClass({
    clear: function() {
      var canvas, ctx;
      canvas = this.getDOMNode();
      ctx = canvas.getContext("2d");
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      return ctx.restore();
    },
    draw: function() {
      var canvas;
      this.clear();
      canvas = this.getDOMNode();
      return this.props.drawFn(canvas);
    },
    sizeCanvas: function() {
      var canvas, rect;
      canvas = this.getDOMNode();
      rect = canvas.getBoundingClientRect();
      if (canvas.width !== rect.width || canvas.height !== rect.height) {
        canvas.width = rect.width;
        canvas.height = rect.height;
        return true;
      }
      return false;
    },
    handleResize: function() {
      if (this.sizeCanvas()) {
        return this.draw();
      }
    },
    componentDidMount: function() {
      this.sizeCanvas();
      this.draw();
      return window.addEventListener("resize", this.handleResize);
    },
    componentWillUnmount: function() {
      return window.removeEventListener("resize", this.handleResize);
    },
    render: function() {
      return R.canvas({});
    }
  });

  GridView = React.createClass({
    drawFn: function(canvas) {
      var graph;
      graph = canvas.graph != null ? canvas.graph : canvas.graph = new Graph(canvas, -10, 10, -10, 10);
      return graph.drawGrid();
    },
    render: function() {
      return CanvasView({
        drawFn: this.drawFn
      });
    }
  });

  GraphView = React.createClass({
    getDefaultProps: function() {
      return {
        spreadOffset: 0
      };
    },
    drawFn: function(canvas) {
      var apply, graph, graphFn, s, spreadOffset, styleOpts, _ref, _ref1;
      _ref = this.props, apply = _ref.apply, spreadOffset = _ref.spreadOffset, styleOpts = _ref.styleOpts;
      graph = canvas.graph != null ? canvas.graph : canvas.graph = new Graph(canvas, -10, 10, -10, 10);
      s = (_ref1 = this.compileString_) != null ? _ref1 : apply.compileString();
      graphFn = eval("(function (x) { var spreadOffset = " + spreadOffset + "; return " + s + "; })");
      if (apply instanceof Param && apply !== editor.xParam) {
        if (apply.axis === "x") {
          return graph.drawVerticalLine(graphFn(0), styleOpts);
        } else if (apply.axis === "result") {
          return graph.drawHorizontalLine(graphFn(0), styleOpts);
        }
      } else {
        return graph.drawGraph(graphFn, styleOpts);
      }
    },
    render: function() {
      return CanvasView({
        drawFn: this.drawFn,
        ref: "canvas"
      });
    },
    componentDidUpdate: function() {
      var apply, drawOptions, spreadOffset, styleOpts, _ref;
      _ref = this.props, apply = _ref.apply, spreadOffset = _ref.spreadOffset, styleOpts = _ref.styleOpts;
      this.compileString_ = apply.compileString();
      drawOptions = _.extend({
        compileString_: this.compileString_,
        spreadOffset: spreadOffset,
        axis: apply.axis
      }, styleOpts);
      if (_.isEqual(drawOptions, this.lastDrawOptions_)) {
        return;
      }
      this.lastDrawOptions_ = drawOptions;
      return this.refs.canvas.draw();
    }
  });

  MainGraphView = React.createClass({
    render: function() {
      var apply, graphViews, i, neg, param, spreadDistance, spreadNum, spreadOffset, styleOpts, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      graphViews = [];
      if (editor.spreadParam()) {
        spreadDistance = 0.5;
        spreadNum = 5;
        for (i = _i = 1; 1 <= spreadNum ? _i < spreadNum : _i > spreadNum; i = 1 <= spreadNum ? ++_i : --_i) {
          styleOpts = _.clone(config.styles.selectedApply);
          styleOpts.opacity = lerp(i, 1, spreadNum, config.spreadOpacityMax, config.spreadOpacityMin);
          _ref = [-1, 1];
          for (_j = 0, _len = _ref.length; _j < _len; _j++) {
            neg = _ref[_j];
            spreadOffset = spreadDistance * i * neg;
            graphViews.push(GraphView({
              apply: editor.root,
              styleOpts: styleOpts,
              spreadOffset: spreadOffset
            }));
          }
        }
      }
      graphViews.push(GraphView({
        apply: editor.root,
        styleOpts: config.styles.selectedApply
      }));
      if (apply = editor.hoveredApply) {
        if (apply.params) {
          _ref1 = apply.params;
          for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
            param = _ref1[_k];
            if (param instanceof Param && param !== editor.xParam) {
              styleOpts = config.styles.param;
            } else {
              styleOpts = config.styles.apply;
            }
            graphViews.push(GraphView({
              apply: param,
              styleOpts: styleOpts
            }));
          }
        }
        graphViews.push(GraphView({
          apply: apply,
          styleOpts: config.styles.hoveredApply
        }));
      }
      if (param = editor.hoveredParam) {
        graphViews.push(GraphView({
          apply: param,
          styleOpts: config.styles.hoveredParam
        }));
      }
      return R.div({
        className: "main"
      }, R.span({}, GridView({}), graphViews), editor.shaderView ? R.span({
        style: {
          opacity: config.shaderOpacity
        }
      }, ShaderGraphView({
        apply: (_ref2 = editor.hoveredApply) != null ? _ref2 : editor.root
      })) : void 0);
    }
  });

  ObjectManager = (function() {
    function ObjectManager() {
      this.idCounter_ = 0;
      this.classNames_ = {};
      this.builtInObjects_ = {};
    }

    ObjectManager.prototype.assignId = function(object) {
      var id;
      this.idCounter_++;
      id = "id-" + this.idCounter_ + Date.now() + Math.floor(1e9 * Math.random());
      return object.__id = id;
    };

    ObjectManager.prototype.registerClass = function(className, classConstructor) {
      this.classNames_[className] = classConstructor;
      return classConstructor.prototype.__className = className;
    };

    ObjectManager.prototype.registerBuiltInObject = function(id, object) {
      this.builtInObjects_[id] = object;
      return object.__id = id;
    };

    ObjectManager.prototype.deconstruct = function(object) {
      var objects, root, serialize,
        _this = this;
      objects = {};
      serialize = function(object, force) {
        var entry, id, key, result, value, _i, _len;
        if (force == null) {
          force = false;
        }
        if (!force && (id = object != null ? object.__id : void 0)) {
          if (!_this.builtInObjects_[id] && !objects[id]) {
            objects[id] = serialize(object, true);
          }
          return {
            __ref: id
          };
        }
        if (_.isArray(object)) {
          result = [];
          for (_i = 0, _len = object.length; _i < _len; _i++) {
            entry = object[_i];
            result.push(serialize(entry));
          }
          return result;
        }
        if (_.isObject(object)) {
          result = {};
          for (key in object) {
            if (!__hasProp.call(object, key)) continue;
            value = object[key];
            result[key] = serialize(value);
          }
          if (object.__className) {
            result.__className = object.__className;
          }
          return result;
        }
        return object != null ? object : null;
      };
      root = serialize(object);
      return {
        objects: objects,
        root: root
      };
    };

    ObjectManager.prototype.reconstruct = function(_arg) {
      var constructObject, constructedObjects, derefObject, id, object, objects, root,
        _this = this;
      objects = _arg.objects, root = _arg.root;
      constructedObjects = {};
      constructObject = function(object) {
        var classConstructor, className, constructedObject, key, value;
        if (className = object.__className) {
          classConstructor = _this.classNames_[className];
          constructedObject = new classConstructor();
          for (key in object) {
            if (!__hasProp.call(object, key)) continue;
            value = object[key];
            if (key !== "__className") {
              constructedObject[key] = value;
            }
          }
          return constructedObject;
        }
        return object;
      };
      for (id in objects) {
        if (!__hasProp.call(objects, id)) continue;
        object = objects[id];
        constructedObjects[id] = constructObject(object);
      }
      root = constructObject(root);
      derefObject = function(object) {
        var key, value, _ref, _results;
        if (!_.isObject(object)) {
          return;
        }
        _results = [];
        for (key in object) {
          if (!__hasProp.call(object, key)) continue;
          value = object[key];
          if (id = value != null ? value.__ref : void 0) {
            _results.push(object[key] = (_ref = _this.builtInObjects_[id]) != null ? _ref : constructedObjects[id]);
          } else {
            _results.push(derefObject(value));
          }
        }
        return _results;
      };
      for (id in constructedObjects) {
        if (!__hasProp.call(constructedObjects, id)) continue;
        object = constructedObjects[id];
        derefObject(object);
      }
      derefObject(root);
      return root;
    };

    return ObjectManager;

  })();

  objectManager = new ObjectManager();

  truncate = function(value) {
    var s;
    s = value.toFixed(4);
    if (s.indexOf(".") !== -1) {
      s = s.replace(/\.?0*$/, "");
    }
    return s;
  };

  ContentEditableMixin = {
    isFocused: function() {
      if (!this.isMounted()) {
        return false;
      }
      return this.getDOMNode() === document.activeElement;
    },
    cleanAndGetValue: function() {
      var el, text;
      el = this.getDOMNode();
      text = el.textContent;
      if (el.innerHTML !== text) {
        el.innerHTML = text;
      }
      return text;
    },
    focus: function() {
      return this.getDOMNode().focus();
    },
    focusAndSelect: function() {
      this.focus();
      document.execCommand("selectAll", false, null);
      return this.forceUpdate();
    }
  };

  ParamValueView = React.createClass({
    mixins: [ContentEditableMixin],
    shouldComponentUpdate: function() {
      return !this.isFocused();
    },
    cursor: function() {
      if (this.isFocused()) {
        return "text";
      } else if (this.props.param.axis === "x") {
        return "ew-resize";
      } else {
        return "ns-resize";
      }
    },
    handleMouseDown: function(e) {
      var originalValue, originalX, originalY, param;
      if (this.isFocused()) {
        return;
      }
      e.preventDefault();
      param = this.props.param;
      e.preventDefault();
      originalX = e.clientX;
      originalY = e.clientY;
      originalValue = param.value;
      return editor.dragging = {
        cursor: this.cursor(),
        onMove: function(e) {
          var d, dx, dy, multiplier;
          editor.hoveredParam = param;
          dx = e.clientX - originalX;
          dy = -(e.clientY - originalY);
          d = param.axis === "x" ? dx : dy;
          multiplier = 0.1;
          return param.value = originalValue + d * multiplier;
        },
        onUp: function(e) {
          return editor.hoveredParam = null;
        }
      };
    },
    handleInput: function(e) {
      return this.props.param.value = +this.cleanAndGetValue();
    },
    render: function() {
      var param,
        _this = this;
      param = this.props.param;
      return R.span({
        className: "paramValue",
        contentEditable: true,
        onMouseDown: this.handleMouseDown,
        onDoubleClick: this.focusAndSelect,
        onInput: this.handleInput,
        style: {
          cursor: this.cursor()
        }
      }, (function() {
        if (editor.xParam === param) {
          return R.i({}, "x");
        } else if (editor.yParam === param) {
          return R.i({}, "y");
        } else {
          return truncate(param.value);
        }
      })());
    }
  });

  ParamTitleView = React.createClass({
    mixins: [ContentEditableMixin],
    cursor: function() {
      if (this.isFocused()) {
        return "text";
      } else {
        return "-webkit-grab";
      }
    },
    handleMouseDown: function(e) {
      var el, offset, rect,
        _this = this;
      if (this.isFocused()) {
        return;
      }
      e.preventDefault();
      el = this.getDOMNode();
      rect = el.getBoundingClientRect();
      offset = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
      editor.dragging = {
        cursor: "-webkit-grabbing"
      };
      return onceDragConsummated(e, function() {
        return editor.dragging = {
          cursor: "-webkit-grabbing",
          offset: offset,
          render: function() {
            return ParamView({
              param: _this.props.param
            });
          },
          transclusion: _this.props.param
        };
      });
    },
    handleInput: function() {
      return this.props.param.title = this.cleanAndGetValue();
    },
    render: function() {
      var param;
      param = this.props.param;
      return R.span({
        className: "paramTitle",
        contentEditable: true,
        onMouseDown: this.handleMouseDown,
        onDoubleClick: this.focusAndSelect,
        onInput: this.handleInput,
        style: {
          cursor: this.cursor()
        }
      }, param.title);
    }
  });

  ParamView = React.createClass({
    handleClick: function(e) {
      var param;
      param = this.props.param;
      if (key.command) {
        if (param.axis === "result") {
          return param.axis = "x";
        } else {
          return param.axis = "result";
        }
      } else if (key.shift) {
        if (editor.xParam === param) {
          return editor.xParam = null;
        } else {
          return editor.xParam = param;
        }
      } else if (key.option) {
        if (editor.yParam === param) {
          return editor.yParam = null;
        } else {
          return editor.yParam = param;
        }
      }
    },
    handleMouseEnter: function() {
      return editor.hoveredParam = this.props.param;
    },
    handleMouseLeave: function() {
      return editor.hoveredParam = null;
    },
    render: function() {
      var classNames;
      classNames = cx({
        param: true,
        hovered: editor.hoveredParam === this.props.param
      });
      return R.div({
        className: classNames,
        onClick: this.handleClick,
        onMouseEnter: this.handleMouseEnter,
        onMouseLeave: this.handleMouseLeave
      }, ParamTitleView({
        param: this.props.param
      }), ParamValueView({
        param: this.props.param
      }));
    }
  });

  /*
  opts
    canvas: Canvas DOM element
    vertex: glsl source string
    fragment: glsl source string
    uniforms: a hash of names to values, the type is inferred as follows:
      Number or [Number]: float
      [Number, Number]: vec2
      [Number, Number, Number]: vec3
      [Number, Number, Number, Number]: vec4
      DOMElement: Sampler2D (e.g. Image/Video/Canvas)
      TODO: a way to force an arbitrary type
  
  
  to set uniforms,
  */


  Shader = (function() {
    function Shader(canvas) {
      this.canvas = canvas;
      this.vertexSrc = null;
      this.fragmentSrc = null;
      this.uniforms = {};
      this.gl_ = this.canvas.getContext("experimental-webgl", {
        premultipliedAlpha: false
      });
      this.program_ = this.gl_.createProgram();
      this.shaders_ = {};
      this.textures_ = [];
    }

    Shader.prototype.setVertexSrc = function(src) {
      this.vertexSrc = src;
      return this.replaceShader_(this.vertexSrc, this.gl_.VERTEX_SHADER);
    };

    Shader.prototype.setFragmentSrc = function(src) {
      this.fragmentSrc = src;
      return this.replaceShader_(this.fragmentSrc, this.gl_.FRAGMENT_SHADER);
    };

    Shader.prototype.replaceShader_ = function(src, type) {
      var shader;
      if (this.shaders_[type]) {
        this.gl_.detachShader(this.program_, this.shaders_[type]);
      }
      shader = this.gl_.createShader(type);
      this.gl_.shaderSource(shader, src);
      this.gl_.compileShader(shader);
      this.gl_.attachShader(this.program_, shader);
      this.gl_.deleteShader(shader);
      this.shaders_[type] = shader;
      return this.linkAndUseShaders_();
    };

    Shader.prototype.linkAndUseShaders_ = function() {
      if (this.vertexSrc && this.fragmentSrc) {
        this.gl_.linkProgram(this.program_);
        this.gl_.useProgram(this.program_);
        return this.refreshUniforms_();
      }
    };

    Shader.prototype.setUniforms = function(uniforms) {
      this.uniforms = uniforms;
      return this.refreshUniforms_();
    };

    Shader.prototype.refreshUniforms_ = function() {
      var name, value, _ref, _results;
      _ref = this.uniforms;
      _results = [];
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        _results.push(this.setUniform_(name, value));
      }
      return _results;
    };

    Shader.prototype.setUniform_ = function(name, value) {
      var location, texture;
      location = this.gl_.getUniformLocation(this.program_, name);
      if (_.isNumber(value)) {
        return this.gl_.uniform1fv(location, [value]);
      } else if (_.isArray(value)) {
        switch (value.length) {
          case 1:
            return this.gl_.uniform1fv(location, value);
          case 2:
            return this.gl_.uniform2fv(location, value);
          case 3:
            return this.gl_.uniform3fv(location, value);
          case 4:
            return this.gl_.uniform4fv(location, value);
        }
      } else if (value.nodeName) {
        texture = this.getTexture(value);
        this.gl_.activeTexture(this.gl_.TEXTURE0 + texture.i);
        this.gl_.texImage2D(this.gl_.TEXTURE_2D, 0, this.gl_.RGBA, this.gl_.RGBA, this.gl_.UNSIGNED_BYTE, value);
        return this.gl_.uniform1i(location, texture.i);
      } else if (!value) {
        return false;
      }
    };

    Shader.prototype.draw = function() {
      if (!this.initialized_) {
        this.gl_.useProgram(this.program_);
        this.bufferAttribute_("vertexPosition", [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]);
        return this.gl_.drawArrays(this.gl_.TRIANGLES, 0, 6);
      }
    };

    Shader.prototype.bufferAttribute_ = function(attrib, data, size) {
      var buffer, location;
      if (size == null) {
        size = 2;
      }
      location = this.gl_.getAttribLocation(this.program_, attrib);
      buffer = this.gl_.createBuffer();
      this.gl_.bindBuffer(this.gl_.ARRAY_BUFFER, buffer);
      this.gl_.bufferData(this.gl_.ARRAY_BUFFER, new Float32Array(data), this.gl_.STATIC_DRAW);
      this.gl_.enableVertexAttribArray(location);
      return this.gl_.vertexAttribPointer(location, size, this.gl_.FLOAT, false, 0, 0);
    };

    return Shader;

  })();

  ShaderGraphView = React.createClass({
    sizeCanvas: function() {
      var canvas, rect;
      canvas = this.getDOMNode();
      rect = canvas.getBoundingClientRect();
      if (canvas.width !== rect.width || canvas.height !== rect.height) {
        canvas.width = rect.width;
        canvas.height = rect.height;
        return true;
      }
      return false;
    },
    handleResize: function() {
      if (this.sizeCanvas()) {
        return this.refreshGraph();
      }
    },
    refreshGraph: function() {
      var apply, canvas, fragmentSrc, s, shader, vertexSrc;
      apply = this.props.apply;
      canvas = this.getDOMNode();
      shader = canvas.shader != null ? canvas.shader : canvas.shader = new Shader(canvas);
      s = apply.compileGlslString();
      vertexSrc = "precision mediump float;\n\nattribute vec3 vertexPosition;\nvarying vec2 position;\n\nvoid main() {\n  gl_Position = vec4(vertexPosition, 1.0);\n  position = (vertexPosition.xy + 1.0) * 0.5;\n}";
      fragmentSrc = "precision mediump float;\n\nvarying vec2 position;\n\nvoid main() {\n  float x = mix(-10., 10., position.x);\n  float y = mix(-10., 10., position.y);\n  float outputValue = " + s + ";\n  gl_FragColor = vec4(vec3(outputValue), 1);\n}";
      shader.setVertexSrc(vertexSrc);
      shader.setFragmentSrc(fragmentSrc);
      return shader.draw();
    },
    componentDidMount: function() {
      this.sizeCanvas();
      this.refreshGraph();
      return window.addEventListener("resize", this.handleResize);
    },
    componentDidUpdate: function() {
      return this.refreshGraph();
    },
    componentWillUnmount: function() {
      return window.removeEventListener("resize", this.handleResize);
    },
    render: function() {
      return R.canvas({});
    }
  });

  window.config = config = {
    minGridSpacing: 70,
    hitTolerance: 15,
    snapTolerance: 5,
    resolution: 0.5,
    spreadOpacityMax: 0.2,
    spreadOpacityMin: 0.02,
    shaderOpacity: 0.5,
    styles: {
      param: {
        color: "green",
        opacity: 0.4
      },
      hoveredParam: {
        color: "green",
        opacity: 1
      },
      apply: {
        color: "#000",
        opacity: 0.1
      },
      hoveredApply: {
        color: "#900"
      },
      selectedApply: {
        color: "#000"
      }
    }
  };

  editor = null;

  window.init = function() {
    var eventName, _i, _len, _ref;
    loadState();
    window.addEventListener("pointermove", pointermove);
    window.addEventListener("pointerup", pointerup);
    _ref = ["mousedown", "mousemove", "mouseup", "keydown", "scroll"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eventName = _ref[_i];
      window.addEventListener(eventName, refresh);
    }
    return refresh();
  };

  refresh = function() {
    return requestAnimationFrame(function() {
      refreshView();
      return saveState();
    });
  };

  closestDataFor = function(el, property) {
    var found, _ref;
    while ((el != null ? el.nodeType : void 0) === Node.ELEMENT_NODE) {
      if (found = (_ref = el.dataFor) != null ? _ref[property] : void 0) {
        return found;
      }
      el = el.parentNode;
    }
    return void 0;
  };

  pointermove = function(e) {
    var _ref;
    editor.mousePosition = {
      x: e.clientX,
      y: e.clientY
    };
    return (_ref = editor.dragging) != null ? typeof _ref.onMove === "function" ? _ref.onMove(e) : void 0 : void 0;
  };

  pointerup = function(e) {
    var p, _base, _ref, _ref1;
    if ((_ref = editor.dragging) != null) {
      if (typeof _ref.onUp === "function") {
        _ref.onUp(e);
      }
    }
    if (p = (_ref1 = editor.dragging) != null ? _ref1.transclusion : void 0) {
      if (typeof (_base = closestDataFor(e.target, "handleTransclusionDrop")) === "function") {
        _base(p);
      }
    }
    return setTimeout(function() {
      editor.dragging = null;
      return refresh();
    }, 1);
  };

  key("s", function() {
    editor.shaderView = !editor.shaderView;
    return refresh();
  });

  saveState = function() {
    var deconstructed, deconstructedString;
    deconstructed = objectManager.deconstruct(editor);
    deconstructedString = JSON.stringify(deconstructed);
    return window.localStorage.spaceShader = deconstructedString;
  };

  loadState = function() {
    var deconstructed, deconstructedString;
    deconstructedString = window.localStorage.spaceShader;
    if (!deconstructedString) {
      return loadInitialEditor();
    } else {
      deconstructed = JSON.parse(deconstructedString);
      return editor = objectManager.reconstruct(deconstructed);
    }
  };

  loadInitialEditor = function() {
    var a;
    editor = new Editor();
    a = new Param();
    editor.xParam = a;
    return editor.root = a;
  };

  window.reset = function() {
    loadInitialEditor();
    saveState();
    return window.location.reload();
  };

  Param = (function() {
    function Param(value) {
      this.value = value != null ? value : 0;
      objectManager.assignId(this);
      this.title = "";
      this.axis = "result";
    }

    Param.prototype.compileString = function() {
      if (this === editor.xParam) {
        return "x";
      } else if (this === editor.spreadParam()) {
        return "(" + this.value + " + spreadOffset)";
      } else {
        return "" + this.value;
      }
    };

    Param.prototype.compileGlslString = function() {
      var floatString;
      if (this === editor.xParam) {
        return "x";
      } else if (this === editor.yParam) {
        return "y";
      } else {
        floatString = "" + this.value;
        if (floatString.indexOf(".") === -1) {
          floatString += ".";
        }
        return floatString;
      }
    };

    return Param;

  })();

  Fn = (function() {
    function Fn(title, defaultParams, compileString, compileGlslString) {
      this.title = title;
      this.defaultParams = defaultParams;
      this.compileString = compileString;
      this.compileGlslString = compileGlslString;
      objectManager.registerBuiltInObject("fn-" + this.title, this);
    }

    return Fn;

  })();

  fnsToAdd = [
    new Fn("", [null, 0], function(a, b) {
      return "" + b;
    }, function(a, b) {
      return "" + b;
    }), new Fn("+", [0, 0], function(a, b) {
      return "(" + a + " + " + b + ")";
    }, function(a, b) {
      return "(" + a + " + " + b + ")";
    }), new Fn("-", [0, 0], function(a, b) {
      return "(" + a + " - " + b + ")";
    }, function(a, b) {
      return "(" + a + " - " + b + ")";
    }), new Fn("*", [1, 1], function(a, b) {
      return "(" + a + " * " + b + ")";
    }, function(a, b) {
      return "(" + a + " * " + b + ")";
    }), new Fn("/", [1, 1], function(a, b) {
      return "(" + a + " / " + b + ")";
    }, function(a, b) {
      return "(" + a + " / " + b + ")";
    }), new Fn("abs", [0], function(a) {
      return "Math.abs(" + a + ")";
    }, function(a) {
      return "abs(" + a + ")";
    }), new Fn("sqrt", [0], function(a) {
      return "Math.sqrt(" + a + ")";
    }, function(a) {
      return "sqrt(" + a + ")";
    }), new Fn("pow", [1, 1], function(a, b) {
      return "Math.pow(Math.abs(" + a + "), " + b + ")";
    }, function(a, b) {
      return "pow(" + a + ", " + b + ")";
    }), new Fn("sin", [0], function(a) {
      return "Math.sin(" + a + ")";
    }, function(a) {
      return "sin(" + a + ")";
    }), new Fn("cos", [0], function(a) {
      return "Math.cos(" + a + ")";
    }, function(a) {
      return "cos(" + a + ")";
    }), new Fn("fract", [0], function(a) {
      return "(" + a + " - Math.floor(" + a + "))";
    }, function(a) {
      return "fract(" + a + ")";
    }), new Fn("floor", [0], function(a) {
      return "Math.floor(" + a + ")";
    }, function(a) {
      return "floor(" + a + ")";
    }), new Fn("ceil", [0], function(a) {
      return "Math.ceil(" + a + ")";
    }, function(a) {
      return "ceil(" + a + ")";
    }), new Fn("min", [0, 0], function(a, b) {
      return "Math.min(" + a + ", " + b + ")";
    }, function(a, b) {
      return "min(" + a + ", " + b + ")";
    }), new Fn("max", [0, 0], function(a, b) {
      return "Math.max(" + a + ", " + b + ")";
    }, function(a, b) {
      return "max(" + a + ", " + b + ")";
    })
  ];

  Apply = (function() {
    function Apply(fn) {
      this.fn = fn;
      objectManager.assignId(this);
      this.params = [];
      if (this.fn) {
        this.initializeDefaultParams();
      }
    }

    Apply.prototype.initializeDefaultParams = function() {
      return this.params = this.fn.defaultParams.map(function(paramValue) {
        var param;
        return param = new Param(paramValue);
      });
    };

    Apply.prototype.setParam = function(index, param) {
      return this.params[index] = param;
    };

    Apply.prototype.compileString = function() {
      var paramCompileStrings, _ref;
      paramCompileStrings = this.params.map(function(param) {
        return param.compileString();
      });
      return (_ref = this.fn).compileString.apply(_ref, paramCompileStrings);
    };

    Apply.prototype.compileGlslString = function() {
      var paramCompileStrings, _ref;
      paramCompileStrings = this.params.map(function(param) {
        return param.compileGlslString();
      });
      return (_ref = this.fn).compileGlslString.apply(_ref, paramCompileStrings);
    };

    Apply.prototype.isStart = function() {
      return this.fn === fnsToAdd[0];
    };

    return Apply;

  })();

  ProvisionalApply = (function() {
    function ProvisionalApply() {
      objectManager.assignId(this);
      this.params = [null];
      this.possibleApplies = fnsToAdd.map(function(fn) {
        return new Apply(fn);
      });
      this.selectedApply = null;
    }

    ProvisionalApply.prototype.setParam = function(index, param) {
      var possibleApply, _i, _len, _ref, _results;
      this.params[index] = param;
      _ref = this.possibleApplies;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        possibleApply = _ref[_i];
        _results.push(possibleApply.setParam(index, param));
      }
      return _results;
    };

    ProvisionalApply.prototype.effectiveApply = function() {
      var _ref;
      return (_ref = this.selectedApply) != null ? _ref : this.params[0];
    };

    ProvisionalApply.prototype.compileString = function() {
      return this.effectiveApply().compileString();
    };

    ProvisionalApply.prototype.compileGlslString = function() {
      return this.effectiveApply().compileGlslString();
    };

    return ProvisionalApply;

  })();

  Editor = (function() {
    function Editor() {
      this.root = null;
      this.xParam = null;
      this.yParam = null;
      this.hoveredParam = null;
      this.hoveredApply = null;
      this.cursor = null;
      this.mousePosition = {
        x: 0,
        y: 0
      };
      this.dragging = null;
      this.shaderView = false;
    }

    Editor.prototype.spreadParam = function() {
      if (this.dragging) {
        return null;
      }
      if (this.hoveredParam === this.xParam || this.hoveredParam === this.yParam) {
        return null;
      }
      return this.hoveredParam;
    };

    Editor.prototype.applies = function() {
      var applies, apply;
      applies = [];
      apply = this.root;
      while (true) {
        applies.unshift(apply);
        if (apply instanceof Param) {
          break;
        }
        apply = apply.params[0];
      }
      return applies;
    };

    Editor.prototype.nextApply = function(refApply) {
      var nextApply;
      nextApply = this.root;
      while (!(nextApply instanceof Param) && nextApply.params[0] !== refApply) {
        nextApply = nextApply.params[0];
      }
      if (nextApply instanceof Param) {
        return void 0;
      } else {
        return nextApply;
      }
    };

    Editor.prototype.removeApply = function(apply) {
      var nextApply;
      if (this.root === apply) {
        return this.root = apply.params[0];
      } else {
        nextApply = this.nextApply(apply);
        if (nextApply) {
          return nextApply.setParam(0, apply.params[0]);
        }
      }
    };

    Editor.prototype.insertApplyAfter = function(apply, refApply) {
      var nextApply;
      if (this.root === refApply) {
        this.root = apply;
        return apply.setParam(0, refApply);
      } else {
        nextApply = this.nextApply(refApply);
        if (nextApply) {
          nextApply.setParam(0, apply);
          return apply.setParam(0, refApply);
        }
      }
    };

    Editor.prototype.replaceApply = function(apply, refApply) {
      this.insertApplyAfter(apply, refApply);
      return this.removeApply(refApply);
    };

    return Editor;

  })();

  objectManager.registerClass("Param", Param);

  objectManager.registerClass("Apply", Apply);

  objectManager.registerClass("ProvisionalApply", ProvisionalApply);

  objectManager.registerClass("Editor", Editor);

  lerp = function(x, dMin, dMax, rMin, rMax) {
    var ratio;
    ratio = (x - dMin) / (dMax - dMin);
    return ratio * (rMax - rMin) + rMin;
  };

  compose = function(f, g) {
    return function(x) {
      return f(g(x));
    };
  };

  if ((_base = Element.prototype).matches == null) {
    _base.matches = (_ref = (_ref1 = Element.prototype.webkitMatchesSelector) != null ? _ref1 : Element.prototype.mozMatchesSelector) != null ? _ref : Element.prototype.oMatchesSelector;
  }

  Element.prototype.closest = function(selector) {
    var fn, parent;
    if (_.isString(selector)) {
      fn = function(el) {
        return el.matches(selector);
      };
    } else {
      fn = selector;
    }
    if (fn(this)) {
      return this;
    } else {
      parent = this.parentNode;
      if ((parent != null) && parent.nodeType === Node.ELEMENT_NODE) {
        return parent.closest(fn);
      } else {
        return void 0;
      }
    }
  };

  
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

// MIT license

(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
                                   || window[vendors[x]+'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); },
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());
;

  onceDragConsummated = function(downEvent, callback) {
    var handleMove, originalX, originalY, removeListeners;
    originalX = downEvent.clientX;
    originalY = downEvent.clientY;
    handleMove = function(moveEvent) {
      var d, dx, dy;
      dx = moveEvent.clientX - originalX;
      dy = moveEvent.clientY - originalY;
      d = Math.max(Math.abs(dx), Math.abs(dy));
      if (d > 3) {
        removeListeners();
        return callback(moveEvent);
      }
    };
    removeListeners = function() {
      window.removeEventListener("mousemove", handleMove);
      return window.removeEventListener("mouseup", removeListeners);
    };
    window.addEventListener("mousemove", handleMove);
    return window.addEventListener("mouseup", removeListeners);
  };

  R = React.DOM;

  cx = React.addons.classSet;

  refreshView = (function() {
    var EditorView;
    EditorView = React.createClass({
      render: function() {
        var _ref2, _ref3;
        return R.div({
          className: "editor",
          style: {
            cursor: (_ref2 = (_ref3 = editor.dragging) != null ? _ref3.cursor : void 0) != null ? _ref2 : ""
          }
        }, MainGraphView({}), R.div({
          className: "manager"
        }, editor.applies().map(function(apply) {
          return ApplyRowView({
            apply: apply,
            key: apply.__id
          });
        })), R.div({
          className: "dragging"
        }, DraggingView({})));
      }
    });
    return function() {
      var editorEl;
      editorEl = document.querySelector("#editor");
      return React.renderComponent(EditorView(), editorEl);
    };
  })();

}).call(this);
